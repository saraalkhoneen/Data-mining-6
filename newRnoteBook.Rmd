### Project Motivation:
In this project, our primary goal is to classify customers as either good or bad credit risks. We aim to assist financial institutions in making informed decisions regarding loan approvals based on an analysis of customers' payment behavior and other relevant attributes, such as age, income, loan amount, and employment status. By utilizing this dataset, we will build predictive models to assess customers' creditworthiness and use these models as tools for risk assessment and decision-making.

### source
The dataset was sourced from the kaggle website in this URL:
  https://www.kaggle.com/datasets/ppb00x/credit-risk-customers 

## General information 
Origonaly our dataset consists of 21 attributes, but we only worked with 21 attributes that are going to help with our study of the credit risks of applicants.
1- Number of Attributes: 21
2- Number of Objects: 1001
3- class name and lable:
  The "class" attribute which describes whether the customer has a good or bad credit risks.

## Attribute description

| Attribute name    | Data type |            Description             |
  |-------------------|-----------|------------------------------------|
  |checking_status    |Nominal    |status of existing checking acount of loan applicant  |
  |duration           |Numeric    |duration of loan in months         |
  |credit_history     |Nominal    |credit history of loan applicant                |
  |savings_status     |Nominal    |status of savings accounts or bonds of the loan applicant    |
  |age                |Numeric    |Age of the loan applicant years       |
  |employment         |Nominal    |current employment status of the loan applicants in number of years              |
  |other_payment_plans|Nominal |represents other payment plans associated with the loan applicant                |
  |personal_status    |Nominal     | represents the sex and martial status of the loan applicant   |
  |housing            |Nominal     |The housing situation of the applicants| 
  |class              |Nominal     |represent wether a credit risk exists or not |
  |credit_amount |numeric     |This attribute represents the amount of credit being requested.  |
  |residence_since |numeric     |This attribute represents the number of years the loan applicant has been residing at their current residence>  |
  |other_parties |nominal     |This attribute represents the other debtors or guarantors associated with the 'loan. It can take one of the following values: 'none', 'co-applicant', or 'guarantor.|
  |foreign_worker |Nominal |This attribute represents whether the loan applicant is a foreign worker or 'not. It can take one of the following values: 'yes' or 'no.|
  |purpose |nominal     |This attribute represents the purpose of the credit for which the loan is being taken. It can take one of the following values: 'car (new)', 'car (used)', 'furniture/equipment', 'radio/television', 'domestic appliances', 'repairs', 'education', 'vacation', 'retraining', or ''business.|
  |existing_credits |nominal     |This attribute represents the number of existing credits the loan applicant has at the time of the loan application. |
  |num_dependents |numeric     |This attribute represents the number of dependents the loan applicant has. |
  |Own_telephone |numeric     |This attribute represents whether the loan applicant has their own 'telephone line or not. It can take one of the following values: 'none', or 'yes.|
  
  ## Summary of the dataset
  
```{r}
setwd("C:/Users/jory0/OneDrive/Desktop/DataMining Phase 3")
```

```{r}
dataset <- read.csv("credit_customers.csv")
```


```{r}
nrow(dataset) 
```

The output is 1000, which is the number of rows
```{r}
ncol(dataset)
```

The output is 21 , which is the number of columns

```{r}
summary(dataset)
```
This summary provides an initial understanding of the data's structure and characteristics. 

now we want to calculate the variance for the numeric attributes to learn about the spread of the data and how close they are from the mean.

```{r}
var_duration <- var(dataset$duration)
```

```{r}
var_age <- var(dataset$age)
```

```{r}
var_amount <- var(dataset$credit_amount)
```


```{r}
print(var_duration)
```

A variance of 145.415 suggests that the data points in the "duration" attribute have some degree of variability. Data points are not tightly clustered around the mean, and there are variations in the durations.


```{r}
print(var_age)
```
129.4013 for the "age" attribute indicates that there is variability in the ages of individuals represented in the dataset. The ages are not highly consistent, and there are differences among individuals.

```{r}
print(var_amount)

```
A very high variance of 7,967,843 for the "credit_amount" attribute suggests a significant spread or variability in the credit amounts requested by individuals in the dataset. Some requests may be substantially higher or lower than the mean credit amount, indicating a wide range of credit requests.


we got a closer look at our data using these statical mearues: 
1- The length 
2- Class type 
3- Central tendancy (mode, mean and median) of each attribute with the Q1 and Q3
4- Variance 
TTo gain deeper insights, we want want to explore and visualize the data further using graphs. 

## Graphs 

1- We created a bar chart for the class label to know if our dataset is balanced or unbalanced. 

```{r}
library(ggplot2)
```

```{r}
ggplot(dataset, aes(x = class)) +
  geom_bar() +
  labs(x = "Good Or Bad Credit Score", y = "Count") +
  ggtitle("Credit Risks Distribution") 

```
From this bar chart we can see that we do not have an imbalanced dataset, with 70% 'good' and 30% 'bad' labeled records this dataset is acceptable as it is and we do not need to take further actions regarding this matter.


2- 

```{r}
ggplot(dataset, aes(x = housing, fill = class)) +
  geom_bar() +
  labs(
    x = "Housing",
    y = "Count",
    title = "Credit Risks based on Housing",
    fill = "Credit Risk"
  )
```
From this graph we interpreted that 'for free' value for the housing attribute has a large percent of the 'bad' class value.

```{r}
forfree_bad_count <- nrow (subset(dataset,housing == "for free" & class == "bad"))

```

To make sure that we had the correct result we used this function and we discovered that more than 40% of customers who live in their houses for free have bad credits.



3- 

```{r}
hist(dataset$age, main = "Histogram of Age", xlab = "Age", ylab = "Frequency", col = "lightblue")
```
We ceated a histogram for the "Age" variable to show the age groups for our sample of customers to give a better understanding for our overall variables values and results.  
most of the custemers age lies between (20 - 50) some custemers being a bit olde . 
4-

```{r}
plot(dataset$credit_amount, dataset$installment_duration,
     xlab = "Credit Amount", ylab = "duration",
     main = "Credit Amount and duration")
```
We created a Scatter plot for the "credit amount" and "duration" attributes to see if there is a correlation between them, from this scatter plot we can say that there is no clear correlation between the duration variable and the credit amount variable

5-


```{r}
# Load the ggplot2 library if not already loaded
library(ggplot2)

# Create a grouped violin plot with 'checking_status' on the x-axis and 'credit_amount' on the y-axis
ggplot(dataset, aes(x = checking_status, y = credit_amount)) +
  geom_violin(fill = "lightblue", color = "blue") +
  labs(x = "Checking Status", y = "Credit Amount", title = "Grouped Violin Plot")


```

The graph illustrates how the credit amounts are distributed within different categories of checking status. Each violin represents a category of checking status, and its width indicates the density of data points. Also whether there are variations in credit amounts based on checking status.



```{r}

total_missing_values <- sum(is.na(dataset))
print(total_missing_values)

```


## Outliers
First we find the range of each one of the attributes which is collected in the statical measures we did in the
first step using the "summary()" function, using the Min and Max to find the range. 
this would help us in finding if the outliers detected fall in the range or not

credit_amount range: [250 , 18424 ]

duration range: [4.0 ,72.0]

Age range [19.00 , 75.00]

```{r}
library(outliers)
```

```{r}
OutAge <- outlier(dataset$age, logical = TRUE)
OutDuration <- outlier(dataset$duration, logical = TRUE)
Outamount <- outlier(dataset$credit_amount, logical = TRUE)
```

We created a variable "OutAge" , "OutDuration" and "Outamount" to store the result of finding the outliers in the dataset , 
logical true which specifies the outliers with true .


```{r}

sum(OutAge)
sum(OutDuration)
sum(Outamount)


```

Then we calculated the sum of All the outliers, the result is 2 for the age / 1 for the duration. / 2  for the credit amount.

```{r}

Find_outlierAge <- which(OutAge == TRUE, arr.ind = TRUE)
Find_outlierDuration <- which(OutDuration == TRUE, arr.ind = TRUE)
Find_outlierAmount <- which(Outamount == TRUE, arr.ind = TRUE)

```
after that we want to know the specefic values of the outliers and we saved them in Find_outlierAge,Find_outlierDuration,Find_outlierAmount

```{r}
outlierRowsAge <- dataset[Find_outlierAge, ]
outlierRowsDuration <- dataset[Find_outlierDuration, ]
outlierRowsAmount <- dataset[Find_outlierAmount, ]

```

```{r}
print(outlierRowsAge)
```
the rows with the Age is found to be outliers 
```{r}
print(outlierRowsDuration)
```
the rows with the Duraction is found to be outliers

```{r}
print(outlierRowsAmount)
```
the rows with the credit_amount is found to be outliers




```{r}
cat("Outliers in credit_amount:", Find_outlierAmount, "\n")
cat("Outliers in duration:", Find_outlierDuration, "\n")
cat("Outliers in age:", Find_outlierAge, "\n")

```

Age: it is impossible to have an age of 331 or 537, this is obvesouly due to
data entry mistakes and/or human error. 
that is why we removed the Age outiers. 

credit_amount: in most financial contexts, a "credit amount" of 1 doesn't make sense. The credit amount is typically a numerical value representing the total amount of credit or loan that an individual or entity has borrowed. It is expected to be a positive numeric value that reflects the amount of money borrowed.
This is also due to data entry mistakes and/or human error. For the value 916 it falls in the range so we wont do anything to it. 
After removing the outlier with a value of '1' we are left with 1 outlier for the attribute 'credit_amount'. 


duration: Loan durations are typically measured in months, and values like 678 months (56+ years) and 1 month may indicate potential issues with the data which could also be due to data entry mistakes and/or human error. 
that is why we removed the duration outiers. 


```{r}
dataset <- dataset[-Find_outlierAge, ]
dataset <- dataset[!(678:nrow(dataset) %in% Find_outlierDuration), ]
dataset <- dataset[dataset$credit_amount != 1, ]
```

finaly removing the outliers for the reasons we mentioned above.





## Checking for Missing Values 

```{r}

total_missing_values <- sum(is.na(dataset))
print(total_missing_values)

```

our dataset has not missing values so no need for filling or deleting any rows in that sense. 


## Data Conversion (Encoding categorical data)/discretization
To prepare the data for analysis, we need to convert certain categorical attributes into numerical values. 

Let's take a closer look at how this is done for specific attributes:

 Encoding "checking_status"

The "checking_status" attribute represents the status of the existing checking account of the loan applicant.

```{r}
dataset$checking_status <- factor(dataset$checking_status, levels = c("<0", "0<=X<200", "no checking"), labels = c(1, 2, 3))
```
We've encoded it as follows:
- "<0" is labeled as 1.
- "0<=X<200" is labeled as 2.
- "no checking" is labeled as 3.

```{r}
dataset$class <- factor(dataset$class, levels = c("bad", "good"), labels = c(0, 1))

```
Encoding "class"
The "class" attribute describes whether the customer is a good or bad credit risk. We've encoded it as follows:

"bad" is labeled as 0.
"good" is labeled as 1

```{r}
dataset$housing = factor(dataset$housing,levels = c("own","for free", "rent"), labels = c(1, 2, 3))
```
Encoding "housing"
The "housing" attribute represents the housing situation of the applicants. We've encoded it as follows:

"own" is labeled as 1.
"for free" is labeled as 2.
"rent" is labeled as 3.

```{r}
dataset$foreign_worker <- factor(dataset$foreign_worker, levels = c("yes", "no"), labels = c(0, 1))
```
Encoding "foreign_worker"
The "foreign_worker" attribute represents whether the loan applicant is a foreign worker or not. We've encoded it as follows:

"yes" is labeled as 0.
"no" is labeled as 1.

```{r}
dataset$credit_history = factor(dataset$credit_history,levels = c("no credits/all paid","all paid", "existing paid", "delayed previously", "critical/other existing credit"), labels = c(1, 2, 3, 4, 5))
```
Encoding "credit_history"
The "credit_history" attribute represents the credit history for the lone applicant.
We've encoded it as follows (going from best case to worst) :

"no credits/all paid" is labeled as 1.
"all paid" is labeled as 2.
"existing paid" is labeled as 3.
"delayed previously" is labeled as 4.
"critical/other existing credit" is labeled as 5.


```{r}
 dataset$savings_status <- factor(dataset$savings_status, levels = c('no known savings', '<100', '100<=X<500', '500<=X<1000', '>=1000'), labels = c(1, 2, 3, 4, 5))
```
Encoding "savings_status"
The "savings_status" attribute represents the status of the savings account or bond of the loan applicant.
We've encoded it as follows (going from least to greatest) :

"no known savings" is labeled as 1.
"<100" is labeled as 2.
"100<=X<500" is labeled as 3.
"500<=X<1000" is labeled as 4.
">=1000" is labeled as 5.

```{r}
dataset$employment <- factor(dataset$employment, levels = c('unemployed', '<1', '1<=X<4', '4<=X<7', '>=7'), labels = c(1, 2, 3, 4, 5))
```
Encoding "employment"
The "empolyment" attribute represents the current employment status of the loan applicant in number of years. 

We've encoded it as follows (going from least to greatest) :

"unemployed" is labeled as 1.
"<1" is labeled as 2.
"1<=X<4" is labeled as 3.
"4<=X<7" is labeled as 4.
">=7" is labeled as 5.

```{r}
dataset$other_parties <- factor(dataset$other_parties, levels = c('none', 'guarantor', 'co applicant'), labels = c(1, 2, 3))
```
Encoding "other_parties"
The "other_parties" attribute represents the debtors or guarantors associated with the loan. 

We've encoded it as follows :

"none" is labeled as 1.
"guarantor" is labeled as 2.
"co applicant" is labeled as 3.

```{r}
 dataset$property_magnitude <- factor(dataset$property_magnitude, levels = c('no known property', 'car', 'life insurance', 'real estate'), labels = c(1, 2, 3, 4))
```
Encoding "property_magnitude"
The "property_magnitude" attribute represents the magnitude of the property owned by the loan applicant.
We've encoded it as follows (going from the least magnitude to the greatest) :

"no known property" is labeled as 1.
"car" is labeled as 2.
"life insurance" is labeled as 3.
"real estate" is labeled as 4.

```{r}
dataset$other_payment_plans <- factor(dataset$other_payment_plans, levels = c('none', 'bank', 'stores'), labels = c(1, 2, 3))
```
Encoding "other_payment_plans"
The "other_payment_plans" attribute represents other payment plans associated with the loan.

We've encoded it as follows :

"none" is labeled as 1.
"bank" is labeled as 2.
"stores insurance" is labeled as 3.

```{r}
 dataset$job <- factor(dataset$job, levels = c('unemp/unskilled non res u', 'unskilled resident', 'skilled', 'high qualif/self emp/mgmt'), labels = c(1, 2, 3, 4))
```
Encoding "job"
The "job" attribute represents the type of job of the loan applicant.

We've encoded it as follows (from least to highest) :

"unemp/unskilled non res u" is labeled as 1.
"unskilled resident" is labeled as 2.
"skilled" is labeled as 3.
"high qualif/self emp/mgmt" is labeled as 4.

```{r}
dataset$own_telephone <- factor(dataset$own_telephone, levels = c("none", "yes"), labels = c(0, 1))
```
Encoding "own_telephone"
The "own_telephone" attribute represents whether the loan applicant has their own telephone line or not.

We've encoded it as follows:

"none" is labeled as 0.
"yes" is labeled as 1.

```{r}
dataset$personal_status <- factor(dataset$personal_status, levels = c('female div/dep/mar', 'div/sep male', 'male mar/wid', 'male single'))
```
Encoding "personal_status"
The "personal_status" attribute represents the sex and marital status of the loan applicant.

Since this attribute's values does not have an actual ranking, we did not use any labels for them.
We used the encoding for this attribute to make it of type 'factor' instead of 'character' since that will help us later on with the classification process.

```{r}
dataset$purpose <- factor(dataset$purpose, levels = c('business', 'domestic appliance', 'education', 'furniture/equipment', 'new car', 'other', 'radio/tv', 'repairs', 'retraining', 'used car'))
```
Encoding "purpose"
The "purpose" attribute represents the purpose of the credit, which the loan is being taken.

Since this attribute's values does not have an actual ranking, we did not use any labels for them.
We used the encoding for this attribute to make it of type 'factor' instead of 'character' since that will help us later on with the classification process.


By encoding these attributes, we convert textual categories into numerical values, making them suitable for use in models.

Print the final preprocessed dataset
```{r}
print(head(dataset))
```



## Normalization
Normalization is an essential data preprocessing step to ensure that numeric attributes are on a consistent scale

Here, we perform min-max scaling to normalize specific attributes in our dataset.


Define the min_max_scaling() function
```{r}
min_max_scaling <- function(x) {return (x - min(x)) / (max(x)- min(x))}
```

We define a custom min-max scaling function, `min_max_scaling()`, which scales values to a range between 0 and 1. This scaling technique preserves the relationships between values while ensuring that all values are within the same range.

Now, let's apply the min-max scaling to the relevant attributes in our dataset:

Normalizing 'age'
We normalize the 'age' variable using min-max scaling:

```{r}
dataset$age <- min_max_scaling(dataset$age)
```


Normalize 'duration' variable

```{r}
dataset$duration <- min_max_scaling(dataset$duration)
```

Normalize 'credit_amount' variable
```{r}
dataset$credit_amount <- min_max_scaling(dataset$credit_amount)

```

After normalization, the values of these attributes will now fall within the range[0,1], ensuring that they are all on a common scale and ready for further analysis.

## Feature Selection : 

## First: chi square 
We will apply chi square for all nominal data in our dataset to measure weather the distribution of the variables and the dataset class is independent or not.

```{r}
tbl1 = table(dataset$class, dataset$purpose)
tbl1 
chisq.test(tbl1)
```

Here we put the attribute 'class' values and the attribute 'purpose' values in a table where the rows represent 'class' and the columns 'purpose', then we checked the chi square for the table.
The p-value we got as a result of this test was 0.0001157 which is less than 0.05. Based on the result we got, we learned that certain purposes for credit applications might be correlated with a higher or lower credit risk, affecting the likelihood of default or other credit-related outcomes.


```{r}
tbl2 = table(dataset$class, dataset$personal_status)
tbl2 
chisq.test(tbl2)
```
Here we put the attribute 'class' values and the attribute 'personal_status' values in a table where the rows represent 'class' and the columns 'personal_status', then we checked the chi square for the table.
The p-value we got as a result of this test was 0.02224 which is less than 0.05. Based on the result we got, we learned that certain personal statuses are correlated with a higher or lower credit risk, affecting the likelihood of default or other credit-related outcomes. 


```{r}
tbl3 = table(dataset$class, dataset$other_parties)
tbl3 
chisq.test(tbl3)
```

Here we put the attribute 'class' values and the attribute 'other_parties' values in a table where the rows represent 'class' and the columns 'other_parties', then we checked the chi square for the table.
The p-value we got as a result of this test was 0.03606 which is less than 0.05. Based on the result we got, we learned that certain parties are correlated with a higher or lower credit risk, affecting the likelihood of default or other credit-related outcomes. 

```{r}
tbl4 = table(dataset$class, dataset$property_magnitude)
tbl4 
chisq.test(tbl4)
```
Here we put the attribute 'class' values and the attribute 'property_magnitude' values in a table where the rows represent 'class' and the columns 'property_magnitude', then we checked the chi square for the table.
The p-value we got as a result of this test was 2.858e-05 which is less than 0.05. Based on the result we got, we learned that certain property magnitudes are correlated with a higher or lower credit risk, affecting the likelihood of default or other credit-related outcomes. 

```{r}
tbl5 = table(dataset$class, dataset$housing)
tbl5 
chisq.test(tbl5)
```
Here we put the attribute 'class' values and the attribute 'housing' values in a table where the rows represent 'class' and the columns 'housing', then we checked the chi square for the table.
The p-value we got as a result of this test was 0.0001117 which is less than 0.05. Based on the result we got, we learned that certain housing types are correlated with a higher or lower credit risk, affecting the likelihood of default or other credit-related outcomes. 

```{r}
tbl6 = table(dataset$class, dataset$job)
tbl6 
chisq.test(tbl6)
```
Here we put the attribute 'class' values and the attribute 'job' values in a table where the rows represent 'class' and the columns 'job', then we checked the chi square for the table.
The p-value we got as a result of this test was 0.5966 which is more than 0.05. Which implies that a person skilles and qualifications in their job are not necessarily correlated with having a higher or lower credit risk.

```{r}
tbl7 = table(dataset$class, dataset$foreign_worker)
tbl7 
chisq.test(tbl7)
```
Here we put the attribute 'class' values and the attribute 'foreign_worker' values in a table where the rows represent 'class' and the columns 'foreign_worker', then we checked the chi square for the table.
The p-value we got as a result of this test was 0.01583 which is less than 0.05. Based on the result we got, we learned that whether someone is a foregin worker or not could lead to a higher or lower credit risk.

```{r}
tbl8 = table(dataset$class, dataset$own_telephone)
tbl8 
chisq.test(tbl8)
```
Here we put the attribute 'class' values and the attribute 'own_telephone' values in a table where the rows represent 'class' and the columns 'own_telephone', then we checked the chi square for the table.
The p-value we got as a result of this test was 0.2789 which is more than 0.05. Which implies that whether a person own a telephone or not does not necessarily correlate with having a higher or lower credit risk.

```{r}
tbl9 = table(dataset$class, dataset$other_payment_plans)
tbl9 
chisq.test(tbl9)

```
Here we put the attribute 'class' values and the attribute 'other_payment_plans' values in a table where the rows represent 'class' and the columns 'other_payment_plans', then we checked the chi square for the table.
The p-value we got as a result of this test was 0.001629 which is less than 0.05. Based on the result we got, we learned that the probability of weather someone will has a high or low credit risk might get affected if they had certain other payment plans.

```{r}
tbl10 = table(dataset$class, dataset$existing_credits)
tbl10
chisq.test(tbl10)
```

```{r}
tbl11 = table(dataset$class, dataset$employment)
tbl11 
chisq.test(tbl11)
```

```{r}
tbl12 = table(dataset$class, dataset$savings_status)
tbl12 
chisq.test(tbl12)
```

```{r}
tbl13 = table(dataset$class, dataset$credit_history)
tbl13 
chisq.test(tbl13)
```

```{r}
tbl14 = table(dataset$class, dataset$checking_status)
tbl14 
chisq.test(tbl14)
```


After conducting the chi square codes and observing the results we noticed that 2 attributes (job and own_telephone) in our dataset might be not very corrlated with our class label (weather someone has a bad or good credit), which means it does not matter what value these attributes will take in each row as the results of the class label are less likely to be affected.

We will not drop the independent columns since we have a relatively small dataset, instead we will use the results we got to help us with the classification of our dataset. 


# Correlation between numeric attributes and the class label

```{r}
set.seed(123)
Data <- data.frame(
  duration = runif(999),
  age = runif(999),
  credit_amount = runif(999),
  residence_since = runif(999),
  num_dependents = runif(999),
  installment_commitment = runif(999),
  Own_telephone = sample(c(0, 1), 999, replace = TRUE),
  Class = sample(c(0, 1), 999, replace = TRUE)
)
```

# Calculate correlation between each numeric column and the 'Class' variable

```{r}
cor_with_class <- sapply(Data[, -ncol(Data)], function(x) cor(x, Data$Class))
```

# Print the correlation values
```{r}
print(cor_with_class)
```


# Load the dataset
```{r}
data <- dataset
target_column <- ncol(data)

X <- data[, 1:(target_column - 1)]  # Predictor variables (exclude the target variable)
Y <- data[, target_column]           # Target variable

roc_scores <- list()

for (i in 1:(target_column - 1)) {
  roc_obj <- roc(Y, X[, i])
  roc_scores[[names(data)[i]]] <- auc(roc_obj)
}

roc_imp <- data.frame(variable = names(roc_scores), score = sapply(roc_scores, function(x) x))
roc_imp <- roc_imp[order(roc_imp$score, decreasing = TRUE),]
```


